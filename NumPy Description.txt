What is NumPy? 
NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object and tools for working with these arrays. It is the fundamental package for scientific computing with Python. It is open-source software. It contains various features including these important ones:

-A powerful N-dimensional array object
-Sophisticated (broadcasting) functions
-Tools for integrating C/C++ and Fortran code
-Useful linear algebra, Fourier transform, and random number capabilities

Besides its obvious scientific uses, NumPy in Python can also be used as an efficient multi-dimensional container of generic data. Arbitrary data types can be defined using Numpy which allows NumPy to seamlessly and speedily integrate with a wide variety of databases.

Install Python NumPy
Numpy can be installed for Mac and Linux users via the following pip command:


pip install numpy

Windows does not have any package manager analogous to that in Linux or Mac. Please download the pre-built Windows installer for NumPy (according to your system configuration and Python version). And then install the packages manually.

Note: All the examples discussed below will not run on an online IDE.

Arrays in NumPy
NumPy’s main object is the homogeneous multidimensional array.

It is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers.
In NumPy, dimensions are called axes. The number of axes is rank.
NumPy’s array class is called ndarray. It is also known by the alias array.

Example:

In this example, we are creating a two-dimensional array which has the rank of 2 as it has 2 axes. The first axis(dimension) is of length 2, i.e., the number of rows, and the second axis(dimension) is of length 3, i.e., the number of columns. The overall shape of the array can be represented as (2, 3)

-=-=-=-=-=-=-=-=-
import numpy as np
 
# Creating array object
arr = np.array( [[ 1, 2, 3],
                 [ 4, 2, 5]] )
 
# Printing type of arr object
print("Array is of type: ", type(arr))
 
# Printing array dimensions (axes)
print("No. of dimensions: ", arr.ndim)
 
# Printing shape of array
print("Shape of array: ", arr.shape)
 
# Printing size (total number of elements) of array
print("Size of array: ", arr.size)
 
# Printing type of elements in array
print("Array stores elements of type: ", arr.dtype)

Output on programiz:

Array is of type:  <class 'numpy.ndarray'>
No. of dimensions:  2
Shape of array:  (2, 3)
Size of array:  6
Array stores elements of type:  int64

#o/p in sypder---
Array is of type:  <class 'numpy.ndarray'>
No. of dimensions:  2
Shape of array:  (2, 3)
Size of array:  6
Array stores elements of type:  int32

-=-=-=-=-=-=-=-
NumPy Array Creation
There are various ways of Numpy array creation in Python. They are as follows:

For example, you can create an array from a regular Python list or tuple using the array() function. The type of the resulting array is deduced from the type of the elements in the sequences.
Often, the element ts of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation. For example: np.zeros, np.ones, np.full, np.empty, etc.

To create sequences of numbers, NumPy provides a function analogous to the range that returns arrays instead of lists.

arange: returns evenly spaced values within a given interval. step size is specified.

linspace: returns evenly spaced values within a given interval. num no. of elements is returned.

Reshaping array: We can use reshape method to reshape an array. Consider an array with shape (a1, a2, a3, …, aN). We can reshape and convert it into another array with shape (b1, b2, b3, …, bM). The only required condition is a1 x a2 x a3 … x aN = b1 x b2 x b3 … x bM. (i.e. the original size of the array remains unchanged.)

Flatten array: We can use flatten method to get a copy of the array collapsed into one dimension. It accepts order argument. The default value is ‘C’ (for row-major order). Use ‘F’ for column-major order.
Note: The type of array can be explicitly defined while creating the array. 

Example:

-=-=-=-=-=-=-=
In this example, we will create Python NumPy arrays with the above-mentioned methods.

import numpy as np
 
# Creating array from list with type float
a = np.array([[1, 2, 4], [5, 8, 7]], dtype = 'float')
print ("Array created using passed list:\n", a)
 
# Creating array from tuple
b = np.array((1 , 3, 2))
print ("\nArray created using passed tuple:\n", b)
 
# Creating a 3X4 array with all zeros
c = np.zeros((3, 4))
print ("\nAn array initialized with all zeros:\n", c)
 
# Create a constant value array of complex type
d = np.full((3, 3), 6, dtype = 'complex')
print ("\nAn array initialized with all 6s."
            "Array type is complex:\n", d)
 
# Create an array with random values
e = np.random.random((2, 2))
print ("\nA random array:\n", e)
 
# Create a sequence of integers
# from 0 to 30 with steps of 5
f = np.arange(0, 30, 5)
print ("\nA sequential array with steps of 5:\n", f)
 
# Create a sequence of 10 values in range 0 to 5
g = np.linspace(0, 5, 10)
print ("\nA sequential array with 10 values between"
                                        "0 and 5:\n", g)
 
# Reshaping 3X4 array to 2X2X3 array
arr = np.array([[1, 2, 3, 4],
                [5, 2, 4, 2],
                [1, 2, 0, 1]])
 
newarr = arr.reshape(2, 2, 3)
 
print ("\nOriginal array:\n", arr)
print ("Reshaped array:\n", newarr)
 
# Flatten array
arr = np.array([[1, 2, 3], [4, 5, 6]])
flarr = arr.flatten()
 
print ("\nOriginal array:\n", arr)
print ("Fattened array:\n", flarr)
Output:

Array created using passed list:
 [[ 1.  2.  4.]
 [ 5.  8.  7.]]

Array created using passed tuple:
 [1 3 2]

An array initialized with all zeros:
 [[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]]

An array initialized with all 6s. Array type is complex:
 [[ 6.+0.j  6.+0.j  6.+0.j]
 [ 6.+0.j  6.+0.j  6.+0.j]
 [ 6.+0.j  6.+0.j  6.+0.j]]

A random array:
 [[ 0.46829566  0.67079389]
 [ 0.09079849  0.95410464]]

A sequential array with steps of 5:
 [ 0  5 10 15 20 25]

A sequential array with 10 values between 0 and 5:
 [ 0.          0.55555556  1.11111111  1.66666667  2.22222222  2.77777778
  3.33333333  3.88888889  4.44444444  5.        ]

Original array:
 [[1 2 3 4]
 [5 2 4 2]
 [1 2 0 1]]
Reshaped array:
 [[[1 2 3]
  [4 5 2]]

 [[4 2 1]
  [2 0 1]]]

Original array:
 [[1 2 3]
 [4 5 6]]
Fattened array:
 [1 2 3 4 5 6]

-=-=-=-=-=-=-=-=

NumPy Array Indexing
Knowing the basics of NumPy array indexing is important for analyzing and manipulating the array object. NumPy in Python offers many ways to do array indexing.

Slicing: Just like lists in Python, NumPy arrays can be sliced. As arrays can be multidimensional, you need to specify a slice for each dimension of the array.

Integer array indexing: In this method, lists are passed for indexing for each dimension. One-to-one mapping of corresponding elements is done to construct a new arbitrary array.

Boolean array indexing: This method is used when we want to pick elements from the array which satisfy some condition.

-=-=-=-=-=-=-=-=-=-=
# Python program to demonstrate
# indexing in numpy
import numpy as np
 
# An exemplar array
arr = np.array([[-1, 2, 0, 4],
                [4, -0.5, 6, 0],
                [2.6, 0, 7, 8],
                [3, -7, 4, 2.0]])
 
# Slicing array
temp = arr[:2, ::2]
print ("Array with first 2 rows and alternate"
                    "columns(0 and 2):\n", temp)
 
# Integer array indexing example
temp = arr[[0, 1, 2, 3], [3, 2, 1, 0]]
print ("\nElements at indices (0, 3), (1, 2), (2, 1),"
                                    "(3, 0):\n", temp)
 
# boolean array indexing example
cond = arr > 0 # cond is a boolean array
temp = arr[cond]
print ("\nElements greater than 0:\n", temp)
Output:

Array with first 2 rows and alternatecolumns(0 and 2):
 [[-1.  0.]
 [ 4.  6.]]

Elements at indices (0, 3), (1, 2), (2, 1),(3, 0):
 [ 4.  6.  0.  3.]

Elements greater than 0:
 [ 2.   4.   4.   6.   2.6  7.   8.   3.   4.   2. ]

-=-=-=-=-=-=-=-=-=-=-=

NumPy Basic Operations
The Plethora of built-in arithmetic functions is provided in Python NumPy.

Operations on a single NumPy array
We can use overloaded arithmetic operators to do element-wise operations on the array to create a new array. In the case of +=, -=, *= operators, the existing array is modified.

-=-=-=-=-=-=-=-=-=
# Python program to demonstrate
# basic operations on single array
import numpy as np
 
a = np.array([1, 2, 5, 3])
 
# add 1 to every element
print ("Adding 1 to every element:", a+1)
 
# subtract 3 from each element
print ("Subtracting 3 from each element:", a-3)
 
# multiply each element by 10
print ("Multiplying each element by 10:", a*10)
 
# square each element
print ("Squaring each element:", a**2)
 
# modify existing array
a *= 2
print ("Doubled each element of original array:", a)
 
# transpose of array
a = np.array([[1, 2, 3], [3, 4, 5], [9, 6, 0]])
 
print ("\nOriginal array:\n", a)
print ("Transpose of array:\n", a.T)
Output:

Adding 1 to every element: [2 3 6 4]
Subtracting 3 from each element: [-2 -1  2  0]
Multiplying each element by 10: [10 20 50 30]
Squaring each element: [ 1  4 25  9]
Doubled each element of original array: [ 2  4 10  6]

Original array:
 [[1 2 3]
 [3 4 5]
 [9 6 0]]
Transpose of array:
 [[1 3 9]
 [2 4 6]
 [3 5 0]]

-=-=-=-=-=-=-=-=

NumPy – Unary Operators
Many unary operations are provided as a method of ndarray class. This includes sum, min, max, etc. These functions can also be applied row-wise or column-wise by setting an axis parameter.

-=-=-=-=-=-=-=-=
# Python program to demonstrate
# unary operators in numpy
import numpy as np
 
arr = np.array([[1, 5, 6],
                [4, 7, 2],
                [3, 1, 9]])
 
# maximum element of array
print ("Largest element is:", arr.max())
print ("Row-wise maximum elements:",
                    arr.max(axis = 1))
 
# minimum element of array
print ("Column-wise minimum elements:",
                        arr.min(axis = 0))
 
# sum of array elements
print ("Sum of all array elements:",
                            arr.sum())
 
# cumulative sum along each row
print ("Cumulative sum along each row:\n",
                        arr.cumsum(axis = 1))
Output:

Largest element is: 9
Row-wise maximum elements: [6 7 9]
Column-wise minimum elements: [1 1 2]
Sum of all array elements: 38
Cumulative sum along each row:
[[ 1  6 12]
 [ 4 11 13]
 [ 3  4 13]]

-=-=-=-=-=-=

NumPy – Binary Operators
These operations apply to the array elementwise and a new array is created. You can use all basic arithmetic operators like +, -, /,  etc. In the case of +=, -=, = operators, the existing array is modified.

-=-=-=-=-=-=-=

# Python program to demonstrate
# binary operators in Numpy
import numpy as np
 
a = np.array([[1, 2],
            [3, 4]])
b = np.array([[4, 3],
            [2, 1]])
 
# add arrays
print ("Array sum:\n", a + b)
 
# multiply arrays (elementwise multiplication)
print ("Array multiplication:\n", a*b)
 
# matrix multiplication
print ("Matrix multiplication:\n", a.dot(b))
Output:

Array sum:
[[5 5]
 [5 5]]
Array multiplication:
[[4 6]
 [6 4]]
Matrix multiplication:
[[ 8  5]
 [20 13]]

-=-=-=-=-=-=-=-=-=
Introduction to NymPy’s ufuncs
NumPy provides familiar mathematical functions such as sin, cos, exp, etc. These functions also operate elementwise on an array, producing an array as output.

Note: All the operations we did above using overloaded operators can be done using ufuncs like np.add, np.subtract, np.multiply, np.divide, np.sum, etc. 

# Python program to demonstrate
# universal functions in numpy
import numpy as np
 
# create an array of sine values
a = np.array([0, np.pi/2, np.pi])
print ("Sine values of array elements:", np.sin(a))
 
# exponential values
a = np.array([0, 1, 2, 3])
print ("Exponent of array elements:", np.exp(a))
 
# square root of array values
print ("Square root of array elements:", np.sqrt(a))
Output:

Sine values of array elements: [  0.00000000e+00   1.00000000e+00   1.22464680e-16]
Exponent of array elements: [  1.           2.71828183   7.3890561   20.08553692]
Square root of array elements: [ 0.          1.          1.41421356  1.73205081]

-=-=-=-=-=-=-=-=-=

NumPy Sorting Arrays
There is a simple np.sort() method for sorting Python NumPy arrays. Let’s explore it a bit. 

# Python program to demonstrate sorting in numpy
import numpy as np
 
a = np.array([[1, 4, 2],
                 [3, 4, 6],
              [0, -1, 5]])
 
# sorted array
print ("Array elements in sorted order:\n",
                    np.sort(a, axis = None))
 
# sort array row-wise
print ("Row-wise sorted array:\n",
                np.sort(a, axis = 1))
 
# specify sort algorithm
print ("Column wise sort by applying merge-sort:\n",
            np.sort(a, axis = 0, kind = 'mergesort'))
 
# Example to show sorting of structured array
# set alias names for dtypes
dtypes = [('name', 'S10'), ('grad_year', int), ('cgpa', float)]
 
# Values to be put in array
values = [('Hrithik', 2009, 8.5), ('Ajay', 2008, 8.7),
           ('Pankaj', 2008, 7.9), ('Aakash', 2009, 9.0)]
            
# Creating array
arr = np.array(values, dtype = dtypes)
print ("\nArray sorted by names:\n",
            np.sort(arr, order = 'name'))
             
print ("Array sorted by graduation year and then cgpa:\n",
                np.sort(arr, order = ['grad_year', 'cgpa']))
Output:

Array elements in sorted order:
[-1  0  1  2  3  4  4  5  6]
Row-wise sorted array:
[[ 1  2  4]
 [ 3  4  6]
 [-1  0  5]]
Column wise sort by applying merge-sort:
[[ 0 -1  2]
 [ 1  4  5]
 [ 3  4  6]]

Array sorted by names:
[('Aakash', 2009, 9.0) ('Ajay', 2008, 8.7) ('Hrithik', 2009, 8.5)
 ('Pankaj', 2008, 7.9)]
Array sorted by graduation year and then cgpa:
[('Pankaj', 2008, 7.9) ('Ajay', 2008, 8.7) ('Hrithik', 2009, 8.5)
 ('Aakash', 2009, 9.0)]

-=-=-=-=-=-=-=-=-=-=-=-=


Arrays in Numpy
Array in Numpy is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers. 
In Numpy, number of dimensions of the array is called rank of the array.
A tuple of integers giving the size of the array along each dimension is known as shape of the array. 
An array class in Numpy is called as ndarray. 
Elements in Numpy arrays are accessed by using square brackets and can be initialized by using nested Python Lists.

Creating a Numpy Array
Arrays in Numpy can be created by multiple ways, with various number of Ranks, defining the size of the Array. 
Arrays can also be created with the use of various data types such as lists, tuples, etc. 
The type of the resultant array is deduced from the type of the elements in the sequences.
Note: Type of array can be explicitly defined while creating the array.

-=-=-=-=-=-=-=-=
# Python program for
# Creation of Arrays
import numpy as np
 
# Creating a rank 1 Array
arr = np.array([1, 2, 3])
print("Array with Rank 1: \n",arr)
 
# Creating a rank 2 Array
arr = np.array([[1, 2, 3],
                [4, 5, 6]])
print("Array with Rank 2: \n", arr)
 
# Creating an array from tuple
arr = np.array((1, 3, 2))
print("\nArray created using "
      "passed tuple:\n", arr)
Run on IDE
Output:

Array with Rank 1: 
 [1 2 3]
Array with Rank 2: 
 [[1 2 3]
 [4 5 6]]

Array created using passed tuple:
 [1 3 2]
 

-=-=-=-=-=-=-=-=

Accessing the array Index
In a numpy array, indexing or accessing the array index can be done in multiple ways. To print a range of an array, slicing is done. Slicing of an array is defining a range in a new array which is used to print a range of elements from the original array. Since, sliced array holds a range of elements of the original array, modifying content with the help of sliced array modifies the original array content.

# Python program to demonstrate
# indexing in numpy array
import numpy as np
 
# Initial Array
arr = np.array([[-1, 2, 0, 4],
                [4, -0.5, 6, 0],
                [2.6, 0, 7, 8],
                [3, -7, 4, 2.0]])
print("Initial Array: ")
print(arr)
 
# Printing a range of Array
# with the use of slicing method
sliced_arr = arr[:2, ::2]
print ("Array with first 2 rows and"
    " alternate columns(0 and 2):\n", sliced_arr)
 
# Printing elements at
# specific Indices
Index_arr = arr[[1, 1, 0, 3], 
                [3, 2, 1, 0]]
print ("\nElements at indices (1, 3), "
    "(1, 2), (0, 1), (3, 0):\n", Index_arr)
Run on IDE
Output:

Initial Array: 
[[-1.   2.   0.   4. ]
 [ 4.  -0.5  6.   0. ]
 [ 2.6  0.   7.   8. ]
 [ 3.  -7.   4.   2. ]]
Array with first 2 rows and alternate columns(0 and 2):
 [[-1.  0.]
 [ 4.  6.]]

Elements at indices (1, 3), (1, 2), (0, 1), (3, 0):
 [0. 6. 2. 3.]

-=-=-=-=-=-=-=

Basic Array Operations
In numpy, arrays allow a wide range of operations which can be performed on a particular array or a combination of Arrays. These operation include some basic Mathematical operation as well as Unary and Binary operations.

# Python program to demonstrate
# basic operations on single array
import numpy as np
 
# Defining Array 1
a = np.array([[1, 2],
              [3, 4]])
 
# Defining Array 2
b = np.array([[4, 3],
              [2, 1]])
               
# Adding 1 to every element
print ("Adding 1 to every element:", a + 1)
 
# Subtracting 2 from each element
print ("\nSubtracting 2 from each element:", b - 2)
 
# sum of array elements
# Performing Unary operations
print ("\nSum of all array "
       "elements: ", a.sum())
 
# Adding two arrays
# Performing Binary operations
print ("\nArray sum:\n", a + b)
Run on IDE
Output:

Adding 1 to every element:
 [[2 3]
 [4 5]]

Subtracting 2 from each element:
 [[ 2  1]
 [ 0 -1]]

Sum of all array elements:  10

Array sum:
 [[5 5]
 [5 5]]
 

-=-=-=-=-=-=-=-=


Data Types in Numpy
Every Numpy array is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers. 
Every ndarray has an associated data type (dtype) object. 
This data type object (dtype) provides information about the layout of the array. 
The values of an ndarray are stored in a buffer which can be thought of as a contiguous block of memory bytes which can be interpreted by the dtype object. 
Numpy provides a large set of numeric datatypes that can be used to construct arrays.
At the time of Array creation, Numpy tries to guess a datatype, but functions that construct arrays usually also include an optional argument to explicitly specify the datatype.


Constructing a Datatype Object
In Numpy, datatypes of Arrays need not to be defined unless a specific datatype is required. Numpy tries to guess the datatype for Arrays which are not predefined in the constructor function.

# Python Program to create
# a data type object
import numpy as np
 
# Integer datatype
# guessed by Numpy
x = np.array([1, 2])  
print("Integer Datatype: ")
print(x.dtype)         
 
# Float datatype
# guessed by Numpy
x = np.array([1.0, 2.0]) 
print("\nFloat Datatype: ")
print(x.dtype)  
 
# Forced Datatype
x = np.array([1, 2], dtype = np.int64)   
print("\nForcing a Datatype: ")
print(x.dtype)
Run on IDE
Output:

Integer Datatype: 
int64

Float Datatype: 
float64

Forcing a Datatype: 
int64
 
Math Operations on DataType array
In Numpy arrays, basic mathematical operations are performed element-wise on the array. These operations are applied both as operator overloads and as functions. Many useful functions are provided in Numpy for performing computations on Arrays such as sum: for addition of Array elements, T: for Transpose of elements, etc.

# Python Program to create
# a data type object
import numpy as np
 
# First Array
arr1 = np.array([[4, 7], [2, 6]], 
                 dtype = np.float64)
                  
# Second Array
arr2 = np.array([[3, 6], [2, 8]], 
                 dtype = np.float64) 
 
# Addition of two Arrays
Sum = np.add(arr1, arr2)
print("Addition of Two Arrays: ")
print(Sum)
 
# Addition of all Array elements
# using predefined sum method
Sum1 = np.sum(arr1)
print("\nAddition of Array elements: ")
print(Sum1)
 
# Square root of Array
Sqrt = np.sqrt(arr1)
print("\nSquare root of Array1 elements: ")
print(Sqrt)
 
# Transpose of Array
# using In-built function 'T'
Trans_arr = arr1.T
print("\nTranspose of Array: ")
print(Trans_arr)
Run on IDE
Output:

Addition of Two Arrays: 
[[ 7. 13.]
 [ 4. 14.]]

Addition of Array elements: 
19.0

Square root of Array1 elements: 
[[2.         2.64575131]
 [1.41421356 2.44948974]]

Transpose of Array: 
[[4. 2.]
 [7. 6.]]
 
-=-=-=-=-=-=-=-=-=

Methods in Numpy
all()
any()
take()
put()
apply_along_axis()
apply_over_axes()
argmin()
argmax()
nanargmin()
nanargmax()
amax()
amin()
insert()
delete()
append()
around()
flip()
fliplr()
flipud()
triu()
tril()
tri()
empty()
empty_like()
zeros()
zeros_like()
ones()
ones_like()
full_like()
diag()
diagflat()
diag_indices()
asmatrix()
bmat()
eye()
roll()
identity()
arange()
place()
extract()
compress()
rot90()
tile()
reshape()
ravel()
isinf()
isrealobj()
isscalar()
isneginf()
isposinf()
iscomplex()
isnan()
iscomplexobj()
isreal()
isfinite()
isfortran()
exp()
exp2()
fix()
hypot()
absolute()
ceil()
floor()
degrees()
radians()
npv()
fv()
pv()
power()
float_power()
log()
log1()
log2()
log10()
dot()
vdot()
trunc()
divide()
floor_divide()
true_divide()
random.rand()
random.randn()
ndarray.flat()
expm1()
bincount()
rint()
equal()
not_equal()
less()
less_equal()
greater()
greater_equal()
prod()
square()
cbrt()
logical_or()
logical_and()
logical_not()
logical_xor()
array_equal()
array_equiv()
sin()
cos()
tan()
sinh()
cosh()
tanh()
arcsin()
arccos()
arctan()
arctan2()

-=-=-=-=-=-=

